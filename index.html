<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Winter Olympics 2026 - Draft Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        h2 {
            color: #667eea;
            margin-bottom: 15px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #667eea;
            color: white;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        th:hover {
            background: #5568d3;
        }

        th.sortable::after {
            content: ' ‚áÖ';
            opacity: 0.5;
            font-size: 0.8em;
        }

        th.sort-asc::after {
            content: ' ‚ñ≤';
            opacity: 1;
        }

        th.sort-desc::after {
            content: ' ‚ñº';
            opacity: 1;
        }

        td {
            padding: 10px 8px;
            border-bottom: 1px solid #eee;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .competitor-name {
            font-weight: 600;
            color: #667eea;
        }

        .medal-input {
            width: 50px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }

        .gold { color: #FFD700; font-weight: bold; }
        .silver { color: #C0C0C0; font-weight: bold; }
        .bronze { color: #CD7F32; font-weight: bold; }

        .score {
            font-size: 1.2em;
            font-weight: bold;
            color: #667eea;
        }

        .rank-1 { background: #FFD70020; }
        .rank-2 { background: #C0C0C020; }
        .rank-3 { background: #CD7F3220; }

        .bonus {
            background: #4ade80;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .update-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 10px;
            width: 100%;
        }

        .update-btn:hover {
            background: #5568d3;
        }

        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 5px solid #667eea;
        }

        .leaderboard-name {
            font-weight: 600;
            font-size: 1.1em;
        }

        .leaderboard-score {
            font-size: 1.3em;
            font-weight: bold;
            color: #667eea;
        }

        @media (max-width: 968px) {
            .layout {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }

            .card {
                padding: 15px;
            }

            h2 {
                font-size: 1.2em;
            }

            table {
                font-size: 0.85em;
            }

            th {
                padding: 8px 4px;
                font-size: 0.75em;
            }

            td {
                padding: 8px 4px;
            }

            .competitor-name {
                font-size: 0.9em;
            }

            .medal-input {
                width: 40px;
                padding: 6px 2px;
                font-size: 0.9em;
            }

            .btn-group {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .update-btn, .wiki-btn {
                padding: 12px 16px;
                font-size: 1em;
                min-height: 44px;
            }

            .leaderboard-row {
                padding: 12px;
                margin: 8px 0;
            }

            .leaderboard-name {
                font-size: 1em;
            }

            .leaderboard-score {
                font-size: 1.1em;
            }

            .table-container {
                max-height: 60vh;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
            }

            table {
                font-size: 0.75em;
            }

            th {
                padding: 6px 2px;
                font-size: 0.7em;
            }

            td {
                padding: 6px 2px;
            }

            .medal-input {
                width: 35px;
                padding: 4px 1px;
            }

            .score {
                font-size: 1em;
            }
        }

        .table-container {
            overflow-x: auto;
            max-height: 70vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .wiki-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }

        .wiki-btn:hover {
            background: #059669;
        }

        .wiki-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .status.loading {
            background: #fef3c7;
            color: #92400e;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèîÔ∏è Winter Olympics 2026 - Draft Game ü•á</h1>

        <div class="layout">
            <div class="card">
                <h2>Country Standings & Medal Count</h2>
                <div class="table-container">
                    <table id="countryTable">
                        <thead>
                            <tr>
                                <th class="sortable" data-column="0" data-type="text">Competitor</th>
                                <th class="sortable" data-column="1" data-type="text">Country</th>
                                <th class="sortable gold" data-column="2" data-type="number">ü•á Gold (5pt)</th>
                                <th class="sortable silver" data-column="3" data-type="number">ü•à Silver (3pt)</th>
                                <th class="sortable bronze" data-column="4" data-type="number">ü•â Bronze (2pt)</th>
                                <th class="sortable" data-column="5" data-type="number">Country Rank</th>
                                <th class="sortable" data-column="6" data-type="number">Total Medals</th>
                                <th class="sortable" data-column="7" data-type="number">Chaos Bonus</th>
                                <th class="sortable" data-column="8" data-type="number">Score</th>
                            </tr>
                        </thead>
                        <tbody id="countryBody">
                        </tbody>
                    </table>
                </div>
                <div class="btn-group">
                    <button class="wiki-btn" onclick="fetchMedalData()" id="wikiBtn">üì° Update from ESPN</button>
                    <button class="update-btn" onclick="calculateScores()">üîÑ Recalculate Scores</button>
                </div>
                <div id="status" class="status hidden"></div>
            </div>

            <div class="card">
                <h2>üèÜ Leaderboard</h2>
                <div id="leaderboard"></div>
            </div>
        </div>
    </div>

    <script>
        const draftData = [
            { competitor: 'Kory', countries: ['Norway', 'Hungary', 'Denmark'] },
            { competitor: 'Cole', countries: ['Germany', 'New Zealand', 'Spain'] },
            { competitor: 'Buck', countries: ['Finland', 'Belgium', 'Croatia'] },
            { competitor: 'Del', countries: ['Canada', 'Australia', 'Latvia'] },
            { competitor: 'Steve', countries: ['USA', 'Slovenia', 'Estonia'] },
            { competitor: 'CP', countries: ['Netherlands', 'Slovakia', 'Ukraine'] },
            { competitor: 'Doug', countries: ['France', 'Individual Neutral Athletes', 'Brazil'] },
            { competitor: 'Beav', countries: ['Switzerland', 'Poland', 'Lithuania'] },
            { competitor: 'John', countries: ['Austria', 'Great Britain', 'Kazakhstan'] },
            { competitor: 'Dunn', countries: ['Italy', 'Sweden', 'Romania'] },
            { competitor: 'KJ', countries: ['China', 'Czech Republic', 'Bulgaria'] },
            { competitor: 'Rob', countries: ['Japan', 'South Korea', 'Turkey'] }
        ];

        // Start with empty medal data - users must click "Update from Wikipedia" to fetch current standings
        let medalData = {};

        function initializeTable() {
            const tbody = document.getElementById('countryBody');
            tbody.innerHTML = '';

            draftData.forEach(player => {
                player.countries.forEach(country => {
                    const medals = medalData[country] || { gold: 0, silver: 0, bronze: 0 };
                    const row = tbody.insertRow();

                    row.innerHTML = `
                        <td class="competitor-name">${player.competitor}</td>
                        <td>${country}</td>
                        <td class="gold" id="gold-${country}">${medals.gold}</td>
                        <td class="silver" id="silver-${country}">${medals.silver}</td>
                        <td class="bronze" id="bronze-${country}">${medals.bronze}</td>
                        <td id="rank-${country}">-</td>
                        <td id="total-${country}">${medals.gold + medals.silver + medals.bronze}</td>
                        <td id="bonus-${country}">0</td>
                        <td id="score-${country}" class="score">0</td>
                    `;
                });
            });

            calculateScores();
            makeSortable();
        }

        function makeSortable() {
            const table = document.getElementById('countryTable');
            const headers = table.querySelectorAll('th.sortable');

            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const column = parseInt(this.dataset.column);
                    const type = this.dataset.type;
                    const tbody = table.querySelector('tbody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));

                    // Determine sort direction - toggle between asc and desc
                    let newSort;
                    if (this.classList.contains('sort-asc')) {
                        newSort = 'desc';
                    } else if (this.classList.contains('sort-desc')) {
                        newSort = 'asc';
                    } else {
                        newSort = 'asc'; // First click = ascending
                    }

                    // Remove sort classes from all headers
                    headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));

                    // Add sort class to current header
                    this.classList.add(newSort === 'asc' ? 'sort-asc' : 'sort-desc');

                    // Sort rows
                    rows.sort((a, b) => {
                        const aCell = a.cells[column];
                        const bCell = b.cells[column];

                        let aVal = aCell.textContent.trim();
                        let bVal = bCell.textContent.trim();

                        if (type === 'number') {
                            // Handle special cases like "+8" for bonus, "-" for rank
                            aVal = aVal === '-' ? -999 : parseFloat(aVal.replace(/[^0-9.+-]/g, '')) || 0;
                            bVal = bVal === '-' ? -999 : parseFloat(bVal.replace(/[^0-9.+-]/g, '')) || 0;

                            // Ascending: low to high (1, 2, 3...)
                            // Descending: high to low (3, 2, 1...)
                            if (newSort === 'asc') {
                                return aVal - bVal; // Low to high
                            } else {
                                return bVal - aVal; // High to low
                            }
                        } else {
                            // Text comparison
                            if (newSort === 'asc') {
                                return aVal.localeCompare(bVal); // A to Z
                            } else {
                                return bVal.localeCompare(aVal); // Z to A
                            }
                        }
                    });

                    // Reappend sorted rows
                    rows.forEach(row => tbody.appendChild(row));
                });
            });
        }

        function calculateScores() {
            const scores = {};

            // First, determine the top 10 countries by total medal count
            const countryRankings = [];
            Object.keys(medalData).forEach(country => {
                const medals = medalData[country];
                const totalMedals = medals.gold + medals.silver + medals.bronze;
                if (totalMedals > 0) {
                    countryRankings.push({
                        country: country,
                        total: totalMedals,
                        gold: medals.gold,
                        silver: medals.silver,
                        bronze: medals.bronze
                    });
                }
            });

            // Sort by total medals (desc), then gold (desc), then silver (desc)
            countryRankings.sort((a, b) => {
                if (b.total !== a.total) return b.total - a.total;
                if (b.gold !== a.gold) return b.gold - a.gold;
                return b.silver - a.silver;
            });

            // Get top 10 countries
            const top10Countries = new Set(countryRankings.slice(0, 10).map(c => c.country));

            // Create a map of country to rank
            const countryRankMap = {};
            countryRankings.forEach((country, index) => {
                countryRankMap[country.country] = index + 1;
            });

            // Calculate scores for each player
            draftData.forEach(player => {
                scores[player.competitor] = 0;

                player.countries.forEach(country => {
                    const medals = medalData[country] || { gold: 0, silver: 0, bronze: 0 };
                    const totalMedals = medals.gold + medals.silver + medals.bronze;

                    // Base score: Gold = 5pt, Silver = 3pt, Bronze = 2pt
                    let countryScore = (medals.gold * 5) + (medals.silver * 3) + (medals.bronze * 2);

                    // Chaos Modifier: If country is outside top 10, add +2 per medal
                    const isOutsideTop10 = !top10Countries.has(country) && totalMedals > 0;
                    let chaosBonus = 0;
                    if (isOutsideTop10) {
                        chaosBonus = totalMedals * 2;
                        countryScore += chaosBonus;
                    }

                    scores[player.competitor] += countryScore;

                    // Update medal count displays
                    const goldCell = document.getElementById(`gold-${country}`);
                    const silverCell = document.getElementById(`silver-${country}`);
                    const bronzeCell = document.getElementById(`bronze-${country}`);
                    const rankCell = document.getElementById(`rank-${country}`);
                    const totalCell = document.getElementById(`total-${country}`);
                    const bonusCell = document.getElementById(`bonus-${country}`);
                    const scoreCell = document.getElementById(`score-${country}`);

                    if (goldCell) goldCell.textContent = medals.gold;
                    if (silverCell) silverCell.textContent = medals.silver;
                    if (bronzeCell) bronzeCell.textContent = medals.bronze;

                    if (rankCell) {
                        rankCell.textContent = countryRankMap[country] || '-';
                    }

                    if (totalCell) {
                        totalCell.textContent = totalMedals;
                    }

                    if (bonusCell) {
                        bonusCell.textContent = chaosBonus > 0 ? `+${chaosBonus}` : '0';
                    }

                    if (scoreCell) {
                        scoreCell.textContent = countryScore;
                    }
                });
            });

            updateLeaderboard(scores);
        }

        function updateLeaderboard(scores) {
            const leaderboard = document.getElementById('leaderboard');
            const sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);

            leaderboard.innerHTML = '';

            sortedScores.forEach(([competitor, score], index) => {
                const row = document.createElement('div');
                row.className = 'leaderboard-row';
                if (index === 0) row.classList.add('rank-1');
                if (index === 1) row.classList.add('rank-2');
                if (index === 2) row.classList.add('rank-3');

                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;

                row.innerHTML = `
                    <span class="leaderboard-name">${medal} ${competitor}</span>
                    <span class="leaderboard-score">${score}</span>
                `;

                leaderboard.appendChild(row);
            });
        }

        function showStatus(message, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        function hideStatus() {
            const statusEl = document.getElementById('status');
            statusEl.className = 'status hidden';
        }

        async function fetchMedalData() {
            const btn = document.getElementById('wikiBtn');
            btn.disabled = true;
            showStatus('üîÑ Fetching data from ESPN...', 'loading');

            // List of CORS proxies to try (in order)
            const proxies = [
                'https://api.allorigins.win/raw?url=',
                'https://corsproxy.io/?',
                'https://api.codetabs.com/v1/proxy?quest='
            ];

            let html = null;
            let lastError = null;

            // Try each proxy until one works
            for (const proxy of proxies) {
                try {
                    const url = proxy + encodeURIComponent('https://www.espn.com/olympics/winter/2026/medals');
                    const response = await fetch(url);

                    if (response.ok) {
                        html = await response.text();
                        break; // Success! Exit the loop
                    }
                } catch (error) {
                    lastError = error;
                    console.warn(`Proxy ${proxy} failed:`, error);
                }
            }

            if (!html) {
                showStatus('‚ùå All proxies failed. Please try again later.', 'error');
                setTimeout(hideStatus, 5000);
                btn.disabled = false;
                return;
            }

            try {
                // Parse the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                // ESPN uses table elements - find all tables and look for medal data
                const tables = doc.querySelectorAll('table');
                let updatedCount = 0;

                // Look through all tables to find medal data
                tables.forEach(table => {
                    const rows = table.querySelectorAll('tr');

                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td, th');
                        if (cells.length < 4) return; // Need at least country, gold, silver, bronze

                        // Try to find country name and medal counts in the row
                        let countryName = null;
                        let goldIdx = -1, silverIdx = -1, bronzeIdx = -1;

                        // Look through cells to find country name and numeric medal values
                        cells.forEach((cell, idx) => {
                            const text = cell.textContent.trim();

                            // Country name: text that's not a number and longer than 2 chars
                            if (!countryName && text && !/^\d+$/.test(text) && text.length > 2) {
                                const cleaned = text.replace(/\s+/g, ' ').replace(/\*/g, '').trim();
                                // Exclude header text
                                if (cleaned.length > 2 && !['Gold', 'Silver', 'Bronze', 'Total', 'Group', 'Rank'].includes(cleaned)) {
                                    countryName = cleaned;
                                }
                            }

                            // Medal counts are numeric values
                            if (/^\d+$/.test(text)) {
                                if (goldIdx === -1) goldIdx = idx;
                                else if (silverIdx === -1) silverIdx = idx;
                                else if (bronzeIdx === -1) bronzeIdx = idx;
                            }
                        });

                        // If we found a country and medal counts, try to match and update
                        if (countryName && goldIdx !== -1 && silverIdx !== -1 && bronzeIdx !== -1) {
                            const matchedCountry = findMatchingCountry(countryName);

                            if (matchedCountry) {
                                const gold = parseInt(cells[goldIdx]?.textContent.trim()) || 0;
                                const silver = parseInt(cells[silverIdx]?.textContent.trim()) || 0;
                                const bronze = parseInt(cells[bronzeIdx]?.textContent.trim()) || 0;

                                medalData[matchedCountry] = { gold, silver, bronze };
                                updatedCount++;
                            }
                        }
                    });
                });

                // Refresh the table with new data
                initializeTable();

                if (updatedCount > 0) {
                    showStatus(`‚úÖ Successfully updated ${updatedCount} countries from ESPN!`, 'success');
                } else {
                    showStatus('‚ö†Ô∏è No medal data found. ESPN table structure may have changed.', 'error');
                }
                setTimeout(hideStatus, 5000);

            } catch (error) {
                console.error('Error parsing ESPN data:', error);
                showStatus('‚ùå Error: ' + error.message, 'error');
                setTimeout(hideStatus, 5000);
            } finally {
                btn.disabled = false;
            }
        }

        function findMatchingCountry(wikiCountryName) {
            // Get all unique countries from draft data
            const allCountries = new Set();
            draftData.forEach(player => {
                player.countries.forEach(country => allCountries.add(country));
            });

            // Direct match
            if (allCountries.has(wikiCountryName)) {
                return wikiCountryName;
            }

            // Try common variations
            const variations = {
                'United States': 'USA',
                'United Kingdom': 'Great Britain',
                'Republic of Korea': 'South Korea',
                'Korea': 'South Korea',
                'People\'s Republic of China': 'China',
                'Czechia': 'Czech Republic',
                'ROC': 'Individual Neutral Athletes',
                'OAR': 'Individual Neutral Athletes'
            };

            if (variations[wikiCountryName] && allCountries.has(variations[wikiCountryName])) {
                return variations[wikiCountryName];
            }

            // Case-insensitive partial match
            const lowerWiki = wikiCountryName.toLowerCase();
            for (const country of allCountries) {
                if (country.toLowerCase() === lowerWiki) {
                    return country;
                }
            }

            return null;
        }

        initializeTable();

        // Automatically fetch ESPN medal data when page loads
        fetchMedalData();
    </script>
</body>
</html>
